{"version":3,"file":"shaded-relief.js","mappings":"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","sources":["webpack:///./shaded-relief.js"],"sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {OSM, Raster, XYZ} from '../src/ol/source.js';\n\n/**\n * Generates a shaded relief image given elevation data.  Uses a 3x3\n * neighborhood for determining slope and aspect.\n * @param {Array<ImageData>} inputs Array of input images.\n * @param {Object} data Data added in the \"beforeoperations\" event.\n * @return {ImageData} Output image.\n */\nfunction shade(inputs, data) {\n  const elevationImage = inputs[0];\n  const width = elevationImage.width;\n  const height = elevationImage.height;\n  const elevationData = elevationImage.data;\n  const shadeData = new Uint8ClampedArray(elevationData.length);\n  const dp = data.resolution * 2;\n  const maxX = width - 1;\n  const maxY = height - 1;\n  const pixel = [0, 0, 0, 0];\n  const twoPi = 2 * Math.PI;\n  const halfPi = Math.PI / 2;\n  const sunEl = (Math.PI * data.sunEl) / 180;\n  const sunAz = (Math.PI * data.sunAz) / 180;\n  const cosSunEl = Math.cos(sunEl);\n  const sinSunEl = Math.sin(sunEl);\n  let pixelX,\n    pixelY,\n    x0,\n    x1,\n    y0,\n    y1,\n    offset,\n    z0,\n    z1,\n    dzdx,\n    dzdy,\n    slope,\n    aspect,\n    cosIncidence,\n    scaled;\n  function calculateElevation(pixel) {\n    // The method used to extract elevations from the DEM.\n    // In this case the format used is Terrarium\n    // red * 256 + green + blue / 256 - 32768\n    //\n    // Other frequently used methods include the Mapbox format\n    // (red * 256 * 256 + green * 256 + blue) * 0.1 - 10000\n    //\n    return pixel[0] * 256 + pixel[1] + pixel[2] / 256 - 32768;\n  }\n  for (pixelY = 0; pixelY <= maxY; ++pixelY) {\n    y0 = pixelY === 0 ? 0 : pixelY - 1;\n    y1 = pixelY === maxY ? maxY : pixelY + 1;\n    for (pixelX = 0; pixelX <= maxX; ++pixelX) {\n      x0 = pixelX === 0 ? 0 : pixelX - 1;\n      x1 = pixelX === maxX ? maxX : pixelX + 1;\n\n      // determine elevation for (x0, pixelY)\n      offset = (pixelY * width + x0) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n\n      // determine elevation for (x1, pixelY)\n      offset = (pixelY * width + x1) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n\n      dzdx = (z1 - z0) / dp;\n\n      // determine elevation for (pixelX, y0)\n      offset = (y0 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * calculateElevation(pixel);\n\n      // determine elevation for (pixelX, y1)\n      offset = (y1 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * calculateElevation(pixel);\n\n      dzdy = (z1 - z0) / dp;\n\n      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));\n\n      aspect = Math.atan2(dzdy, -dzdx);\n      if (aspect < 0) {\n        aspect = halfPi - aspect;\n      } else if (aspect > halfPi) {\n        aspect = twoPi - aspect + halfPi;\n      } else {\n        aspect = halfPi - aspect;\n      }\n\n      cosIncidence =\n        sinSunEl * Math.cos(slope) +\n        cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);\n\n      offset = (pixelY * width + pixelX) * 4;\n      scaled = 255 * cosIncidence;\n      shadeData[offset] = scaled;\n      shadeData[offset + 1] = scaled;\n      shadeData[offset + 2] = scaled;\n      shadeData[offset + 3] = elevationData[offset + 3];\n    }\n  }\n\n  return {data: shadeData, width: width, height: height};\n}\n\nconst elevation = new XYZ({\n  url: 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png',\n  crossOrigin: 'anonymous',\n  maxZoom: 15,\n  attributions:\n    '<a href=\"https://github.com/tilezen/joerd/blob/master/docs/attribution.md\" target=\"_blank\">Data sources and attribution</a>',\n});\n\nconst raster = new Raster({\n  sources: [elevation],\n  operationType: 'image',\n  operation: shade,\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM(),\n    }),\n    new ImageLayer({\n      opacity: 0.3,\n      source: raster,\n    }),\n  ],\n  view: new View({\n    center: [-13615645, 4497969],\n    zoom: 13,\n  }),\n});\n\nconst controlIds = ['vert', 'sunEl', 'sunAz'];\nconst controls = {};\ncontrolIds.forEach(function (id) {\n  const control = document.getElementById(id);\n  const output = document.getElementById(id + 'Out');\n  control.addEventListener('input', function () {\n    output.innerText = control.value;\n    raster.changed();\n  });\n  output.innerText = control.value;\n  controls[id] = control;\n});\n\nraster.on('beforeoperations', function (event) {\n  // the event.data object will be passed to operations\n  const data = event.data;\n  data.resolution = event.resolution;\n  for (const id in controls) {\n    data[id] = Number(controls[id].value);\n  }\n});\n"],"names":["elevation","url","crossOrigin","maxZoom","attributions","raster","sources","operationType","operation","inputs","data","elevationImage","width","height","elevationData","shadeData","Uint8ClampedArray","length","dp","resolution","maxX","maxY","pixel","twoPi","Math","PI","halfPi","sunEl","sunAz","cosSunEl","cos","sinSunEl","sin","pixelX","pixelY","x0","x1","y0","y1","offset","z0","z1","dzdx","dzdy","slope","aspect","cosIncidence","scaled","calculateElevation","vert","atan","sqrt","atan2","controls","target","layers","source","opacity","view","center","zoom","forEach","id","control","document","getElementById","output","addEventListener","innerText","value","changed","on","event","Number"],"sourceRoot":""}